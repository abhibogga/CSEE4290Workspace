$date
	Thu Oct 23 17:37:14 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module oct_10_checkpoint $end
$var wire 1 ! halt_f $end
$var wire 32 " instruction_memory_v [31:0] $end
$var wire 2 # err_bits [1:0] $end
$var wire 32 $ data_memory_in_v [31:0] $end
$var reg 1 % clk $end
$var reg 1 & clk_en $end
$var reg 1 ' rst $end
$scope module topMod $end
$var wire 1 % clk $end
$var wire 1 & clk_en $end
$var wire 1 ! halt_f $end
$var wire 1 ' rst $end
$var wire 1 ( writeBit $end
$var wire 1 ) readBit $end
$var wire 32 * programCounter [31:0] $end
$var wire 32 + instruction_memory_v [31:0] $end
$var wire 32 , instruction [31:0] $end
$var wire 1 - halt $end
$var wire 2 . err_bits [1:0] $end
$var wire 32 / data_memory_in_v [31:0] $end
$var wire 32 0 dataOutMem [31:0] $end
$var wire 32 1 dataIn [31:0] $end
$var wire 32 2 addressFetch [31:0] $end
$scope module memMod $end
$var wire 1 3 instruction_memory_en $end
$var wire 1 % mem_Clk $end
$var wire 32 4 instruction_memory_a [31:0] $end
$var wire 1 - halt_f $end
$var wire 1 ( data_memory_write $end
$var wire 1 ) data_memory_read $end
$var wire 32 5 data_memory_out_v [31:0] $end
$var wire 32 6 data_memory_a [31:0] $end
$var reg 8 7 a [7:0] $end
$var reg 8 8 b [7:0] $end
$var reg 8 9 c [7:0] $end
$var reg 8 : d [7:0] $end
$var reg 32 ; data_memory_in_v [31:0] $end
$var reg 32 < instruction_memory_v [31:0] $end
$var integer 32 = fd [31:0] $end
$var integer 32 > i [31:0] $end
$upscope $end
$scope module scc $end
$var wire 1 % clk $end
$var wire 1 & clk_en $end
$var wire 32 ? dataIn [31:0] $end
$var wire 32 @ instruction [31:0] $end
$var wire 32 A memoryDataIn [31:0] $end
$var wire 1 ' rst $end
$var wire 1 ( writeFlag $end
$var wire 1 B specialEncoding $end
$var wire 1 C setFlags $end
$var wire 4 D secondLevelDecode [3:0] $end
$var wire 1 E regWrite $end
$var wire 1 F regRead $end
$var wire 32 G readDataSec [31:0] $end
$var wire 32 H readDataFirst [31:0] $end
$var wire 32 I readDataDest [31:0] $end
$var wire 32 J programCounter [31:0] $end
$var wire 4 K out_sourceSecReg [3:0] $end
$var wire 4 L out_sourceFirstReg [3:0] $end
$var wire 16 M out_imm [15:0] $end
$var wire 4 N out_destRegister [3:0] $end
$var wire 1 ) memoryRead $end
$var wire 1 O loadStore $end
$var wire 32 P instructionForID [31:0] $end
$var wire 1 - halt $end
$var wire 2 Q firstLevelDecode [1:0] $end
$var wire 1 R exe_writeToReg $end
$var wire 32 S exe_writeData [31:0] $end
$var wire 4 T exe_readRegSec [3:0] $end
$var wire 4 U exe_readRegFirst [3:0] $end
$var wire 4 V exe_readRegDest [3:0] $end
$var wire 1 W exeOverride $end
$var wire 16 X exeData [15:0] $end
$var wire 1 Y dataRegisterImm $end
$var wire 1 Z dataRegister $end
$var wire 32 [ dataOut [31:0] $end
$var wire 4 \ branchInstruction [3:0] $end
$var wire 1 ] branch $end
$var wire 3 ^ aluFunction [2:0] $end
$var wire 32 _ addressIn [31:0] $end
$var reg 32 ` data_memory_v [31:0] $end
$var reg 2 a err_bits [1:0] $end
$var reg 32 b instruction_memory_v [31:0] $end
$scope module EXE $end
$var wire 1 % clk $end
$var wire 16 c exeData [15:0] $end
$var wire 32 d memoryDataIn [31:0] $end
$var wire 1 ' rst $end
$var wire 1 B specialEncoding $end
$var wire 4 e sourceSecReg [3:0] $end
$var wire 4 f sourceFirstReg [3:0] $end
$var wire 1 C setFlags $end
$var wire 4 g secondLevelDecode [3:0] $end
$var wire 32 h readDataSec [31:0] $end
$var wire 32 i readDataFirst [31:0] $end
$var wire 32 j readDataDest [31:0] $end
$var wire 16 k imm [15:0] $end
$var wire 2 l firstLevelDecode [1:0] $end
$var wire 4 m destReg [3:0] $end
$var wire 4 n branchInstruction [3:0] $end
$var wire 3 o aluFunctions [2:0] $end
$var reg 33 p aluRegister [32:0] $end
$var reg 1 W exeOverride $end
$var reg 4 q flags [3:0] $end
$var reg 4 r flags_next [3:0] $end
$var reg 32 s immExt [31:0] $end
$var reg 32 t memoryAddressOut [31:0] $end
$var reg 32 u memoryDataOut [31:0] $end
$var reg 1 ) memoryRead $end
$var reg 1 ( memoryWrite $end
$var reg 4 v readRegDest [3:0] $end
$var reg 4 w readRegFirst [3:0] $end
$var reg 4 x readRegSec [3:0] $end
$var reg 33 y tempDiff [32:0] $end
$var reg 32 z writeData [31:0] $end
$var reg 1 R writeToReg $end
$upscope $end
$scope module ID $end
$var wire 1 % clk $end
$var wire 1 ' rst $end
$var wire 32 { uc_instr [31:0] $end
$var wire 8 | uc_addr [7:0] $end
$var wire 1 } uc_active $end
$var wire 1 ~ specialBit $end
$var wire 4 !" sourceSecReg [3:0] $end
$var wire 4 "" sourceFirstReg [3:0] $end
$var wire 4 #" secondLevelDecode [3:0] $end
$var wire 32 $" instruction_eff [31:0] $end
$var wire 32 %" instruction [31:0] $end
$var wire 16 &" imm [15:0] $end
$var wire 1 '" hold_if $end
$var wire 2 (" firstLevelDecode [1:0] $end
$var wire 4 )" destReg [3:0] $end
$var wire 4 *" branchCondition [3:0] $end
$var wire 3 +" aluOperationCommands [2:0] $end
$var reg 3 ," aluFunction [2:0] $end
$var reg 1 ] branch $end
$var reg 4 -" branchInstruction [3:0] $end
$var reg 1 Z dataRegister $end
$var reg 1 Y dataRegisterImm $end
$var reg 2 ." firstLevelDecode_out [1:0] $end
$var reg 1 - halt $end
$var reg 1 /" hold_if_cal $end
$var reg 32 0" ifid_instr [31:0] $end
$var reg 32 1" ifid_instr_cal [31:0] $end
$var reg 1 O loadStore $end
$var reg 4 2" out_destRegister [3:0] $end
$var reg 16 3" out_imm [15:0] $end
$var reg 4 4" out_sourceFirstReg [3:0] $end
$var reg 4 5" out_sourceSecReg [3:0] $end
$var reg 1 F regRead $end
$var reg 1 E regWrite $end
$var reg 4 6" secondLevelDecode_out [3:0] $end
$var reg 1 C setFlags $end
$var reg 1 B specialEncoding $end
$scope module URom $end
$var wire 1 % clk $end
$var wire 1 ' rst $end
$var wire 8 7" u_addr [7:0] $end
$var reg 32 8" uc_instr [31:0] $end
$upscope $end
$scope module Ucontrol $end
$var wire 1 % clk $end
$var wire 32 9" ifid_instr [31:0] $end
$var wire 1 ' rst $end
$var wire 1 :" start_seq $end
$var wire 1 ;" uc_op $end
$var wire 1 <" muls $end
$var wire 1 =" mul $end
$var wire 4 >" id_rn [3:0] $end
$var wire 16 ?" id_rm [15:0] $end
$var wire 4 @" id_rd [3:0] $end
$var parameter 32 A" usFilter $end
$var parameter 32 B" usIdle $end
$var reg 1 '" hold_if $end
$var reg 8 C" next_uc_addr [7:0] $end
$var reg 32 D" uPC [31:0] $end
$var reg 32 E" uPC_next [31:0] $end
$var reg 1 } uc_active $end
$var reg 8 F" uc_addr [7:0] $end
$var reg 2 G" ustate [1:0] $end
$var reg 2 H" ustateNext [1:0] $end
$upscope $end
$upscope $end
$scope module IF $end
$var wire 1 % clk $end
$var wire 16 I" exeData [15:0] $end
$var wire 1 W exeOverride $end
$var wire 32 J" fetchedInstruction [31:0] $end
$var wire 16 K" imm16_exe [15:0] $end
$var wire 1 ' rst $end
$var wire 16 L" imm16 [15:0] $end
$var wire 32 M" branchOffsetAddress_exe [31:0] $end
$var wire 32 N" branchOffsetAddress [31:0] $end
$var parameter 32 O" sFilter $end
$var parameter 32 P" sIdle $end
$var reg 32 Q" PC [31:0] $end
$var reg 32 R" PC_next [31:0] $end
$var reg 32 S" filteredInstruction [31:0] $end
$var reg 32 T" programCounter [31:0] $end
$var reg 2 U" state [1:0] $end
$var reg 2 V" stateNext [1:0] $end
$upscope $end
$scope module REGFILE $end
$var wire 1 % clk $end
$var wire 32 W" out_rd [31:0] $end
$var wire 32 X" out_rs1 [31:0] $end
$var wire 32 Y" out_rs2 [31:0] $end
$var wire 4 Z" rd [3:0] $end
$var wire 4 [" rs1 [3:0] $end
$var wire 4 \" rs2 [3:0] $end
$var wire 1 ' rst $end
$var wire 1 R write $end
$var wire 32 ]" writeData [31:0] $end
$var integer 32 ^" i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b0 P"
b1 O"
b0 B"
b1 A"
$end
#0
$dumpvars
b10000 ^"
b0 ]"
b0 \"
b0 ["
b0 Z"
b0 Y"
b0 X"
b0 W"
b0 V"
b0 U"
b0 T"
bx S"
b100 R"
b0 Q"
b100 N"
b0 M"
b100 L"
b0 K"
b1000000000000000000100 J"
b0 I"
b0 H"
b0 G"
b0 F"
b0 E"
b0 D"
b0 C"
b0 @"
b0 ?"
b0 >"
0="
0<"
0;"
0:"
b0 9"
bx 8"
b0 7"
b0 6"
b0 5"
b0 4"
b0 3"
b0 2"
b0 1"
b0 0"
1/"
b0 ."
b0 -"
b0 ,"
b0 +"
b0 *"
b0 )"
b0 ("
0'"
b0 &"
bx %"
b0 $"
b0 #"
b0 ""
b0 !"
0~
0}
b0 |
bx {
b0 z
b0 y
b0 x
b0 w
b0 v
b0 u
b0 t
b0 s
b0 r
b0 q
bx p
b0 o
b0 n
b0 m
b0 l
b0 k
b0 j
b0 i
b0 h
b0 g
b0 f
b0 e
bx d
b0 c
bx b
bx a
bx `
b0 _
b0 ^
0]
b0 \
b0 [
0Z
1Y
b0 X
0W
b0 V
b0 U
b0 T
b0 S
1R
b0 Q
bx P
0O
b0 N
b0 M
b0 L
b0 K
b0 J
b0 I
b0 H
b0 G
1F
1E
b0 D
0C
0B
bx A
b1000000000000000000100 @
bx ?
bx >
bx =
b1000000000000000000100 <
bx ;
bx :
bx 9
bx 8
bx 7
b0 6
b0 5
b0 4
13
b0 2
bx 1
b0 0
bx /
bx .
0-
b1000000000000000000100 ,
bx +
b0 *
0)
0(
1'
1&
1%
bx $
bx #
bx "
z!
$end
#5
0%
#10
b10000 ^"
1%
#15
0%
#20
b10000 ^"
1%
#25
0%
#30
b0 R"
b1 V"
0'
b10000 ^"
1%
#35
0%
#40
b1000000000000000000100 P
b1000000000000000000100 %"
b1000000000000000000100 S"
b100 R"
b1 U"
0/"
1%
#45
0%
#50
b11 N"
b11 L"
b100000010000100000000000000011 P
b100000010000100000000000000011 %"
b100000010000100000000000000011 S"
b100000010000100000000000000011 ,
b100000010000100000000000000011 <
b100000010000100000000000000011 @
b100000010000100000000000000011 J"
b1000 R"
b1000000000000000000100 1"
b100 *
b100 4
b100 J
b100 T"
b100 Q"
1%
#55
0%
#60
b0 N"
b0 L"
b11010000000000000000000000000000 P
b11010000000000000000000000000000 %"
b11010000000000000000000000000000 S"
b11010000000000000000000000000000 ,
b11010000000000000000000000000000 <
b11010000000000000000000000000000 @
b11010000000000000000000000000000 J"
b1100 R"
b1000 *
b1000 4
b1000 J
b1000 T"
b1000 Q"
b0 1"
1%
#65
0%
#70
bx N"
bx L"
bx P
bx %"
bx S"
bx ,
bx <
bx @
bx J"
b10000 R"
b11010000000000000000000000000000 1"
b1100 *
b1100 4
b1100 J
b1100 T"
b1100 Q"
1%
#75
0%
#80
b10100 R"
b10000 *
b10000 4
b10000 J
b10000 T"
b10000 Q"
b0 1"
1%
#85
0%
#90
b11000 R"
bx 1"
b10100 *
b10100 4
b10100 J
b10100 T"
b10100 Q"
1%
#95
0%
#100
b11100 R"
b11000 *
b11000 4
b11000 J
b11000 T"
b11000 Q"
b0 1"
1%
#105
0%
#110
b100000 R"
bx 1"
b11100 *
b11100 4
b11100 J
b11100 T"
b11100 Q"
1%
#115
0%
#120
b100100 R"
b100000 *
b100000 4
b100000 J
b100000 T"
b100000 Q"
b0 1"
1%
#125
0%
#130
b101000 R"
bx 1"
b100100 *
b100100 4
b100100 J
b100100 T"
b100100 Q"
1%
#135
0%
#140
b101100 R"
b101000 *
b101000 4
b101000 J
b101000 T"
b101000 Q"
b0 1"
1%
#145
0%
#150
b110000 R"
bx 1"
b101100 *
b101100 4
b101100 J
b101100 T"
b101100 Q"
1%
#155
0%
#160
b110100 R"
b110000 *
b110000 4
b110000 J
b110000 T"
b110000 Q"
b0 1"
1%
#165
0%
#170
b111000 R"
bx 1"
b110100 *
b110100 4
b110100 J
b110100 T"
b110100 Q"
1%
#175
0%
#180
b111100 R"
b111000 *
b111000 4
b111000 J
b111000 T"
b111000 Q"
b0 1"
1%
#185
0%
#190
b1000000 R"
bx 1"
b111100 *
b111100 4
b111100 J
b111100 T"
b111100 Q"
1%
#195
0%
#200
b1000100 R"
b1000000 *
b1000000 4
b1000000 J
b1000000 T"
b1000000 Q"
b0 1"
1%
#205
0%
#210
b1001000 R"
bx 1"
b1000100 *
b1000100 4
b1000100 J
b1000100 T"
b1000100 Q"
1%
#215
0%
#220
b1001100 R"
b1001000 *
b1001000 4
b1001000 J
b1001000 T"
b1001000 Q"
b0 1"
1%
#225
0%
#230
b1010000 R"
bx 1"
b1001100 *
b1001100 4
b1001100 J
b1001100 T"
b1001100 Q"
1%
#235
0%
#240
b1010100 R"
b1010000 *
b1010000 4
b1010000 J
b1010000 T"
b1010000 Q"
b0 1"
1%
#245
0%
#250
b1011000 R"
bx 1"
b1010100 *
b1010100 4
b1010100 J
b1010100 T"
b1010100 Q"
1%
#255
0%
#260
b1011100 R"
b1011000 *
b1011000 4
b1011000 J
b1011000 T"
b1011000 Q"
b0 1"
1%
#265
0%
#270
b1100000 R"
bx 1"
b1011100 *
b1011100 4
b1011100 J
b1011100 T"
b1011100 Q"
1%
#275
0%
#280
b1100100 R"
b1100000 *
b1100000 4
b1100000 J
b1100000 T"
b1100000 Q"
b0 1"
1%
#285
0%
#290
b1101000 R"
bx 1"
b1100100 *
b1100100 4
b1100100 J
b1100100 T"
b1100100 Q"
1%
#295
0%
#300
b1101100 R"
b1101000 *
b1101000 4
b1101000 J
b1101000 T"
b1101000 Q"
b0 1"
1%
#305
0%
#310
b1110000 R"
bx 1"
b1101100 *
b1101100 4
b1101100 J
b1101100 T"
b1101100 Q"
1%
#315
0%
#320
b1110100 R"
b1110000 *
b1110000 4
b1110000 J
b1110000 T"
b1110000 Q"
b0 1"
1%
#325
0%
#330
b1111000 R"
bx 1"
b1110100 *
b1110100 4
b1110100 J
b1110100 T"
b1110100 Q"
1%
