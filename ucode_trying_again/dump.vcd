$date
	Thu Oct 23 00:45:52 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module ucode_tb $end
$var wire 1 ! halt_f $end
$var wire 32 " instruction_memory_v [31:0] $end
$var wire 2 # err_bits [1:0] $end
$var wire 32 $ data_memory_in_v [31:0] $end
$var reg 1 % clk $end
$var reg 1 & clk_en $end
$var reg 1 ' rst $end
$scope module topMod $end
$var wire 1 % clk $end
$var wire 1 & clk_en $end
$var wire 1 ! halt_f $end
$var wire 1 ' rst $end
$var wire 1 ( writeBit $end
$var wire 1 ) readBit $end
$var wire 32 * programCounter [31:0] $end
$var wire 32 + instruction_memory_v [31:0] $end
$var wire 32 , instruction [31:0] $end
$var wire 1 - halt $end
$var wire 2 . err_bits [1:0] $end
$var wire 32 / data_memory_in_v [31:0] $end
$var wire 32 0 dataOutMem [31:0] $end
$var wire 32 1 dataIn [31:0] $end
$var wire 32 2 addressFetch [31:0] $end
$scope module memMod $end
$var wire 1 3 instruction_memory_en $end
$var wire 1 % mem_Clk $end
$var wire 32 4 instruction_memory_a [31:0] $end
$var wire 1 - halt_f $end
$var wire 1 ( data_memory_write $end
$var wire 1 ) data_memory_read $end
$var wire 32 5 data_memory_out_v [31:0] $end
$var wire 32 6 data_memory_a [31:0] $end
$var reg 8 7 a [7:0] $end
$var reg 8 8 b [7:0] $end
$var reg 8 9 c [7:0] $end
$var reg 8 : d [7:0] $end
$var reg 32 ; data_memory_in_v [31:0] $end
$var reg 32 < instruction_memory_v [31:0] $end
$var integer 32 = fd [31:0] $end
$var integer 32 > i [31:0] $end
$upscope $end
$scope module scc $end
$var wire 1 % clk $end
$var wire 1 & clk_en $end
$var wire 32 ? dataIn [31:0] $end
$var wire 32 @ instruction [31:0] $end
$var wire 32 A memoryDataIn [31:0] $end
$var wire 1 ' rst $end
$var wire 1 ( writeFlag $end
$var wire 32 B ucode_inst [31:0] $end
$var wire 1 C specialEncoding $end
$var wire 1 D setFlags $end
$var wire 4 E secondLevelDecode [3:0] $end
$var wire 1 F regWrite $end
$var wire 1 G regRead $end
$var wire 32 H readDataSec [31:0] $end
$var wire 32 I readDataFirst [31:0] $end
$var wire 32 J readDataDest [31:0] $end
$var wire 32 K programCounter [31:0] $end
$var wire 4 L out_sourceSecReg [3:0] $end
$var wire 4 M out_sourceFirstReg [3:0] $end
$var wire 16 N out_imm [15:0] $end
$var wire 4 O out_destRegister [3:0] $end
$var wire 1 P mul_trigger $end
$var wire 1 ) memoryRead $end
$var wire 1 Q loadStore $end
$var wire 32 R instructionForID [31:0] $end
$var wire 1 - halt $end
$var wire 2 S firstLevelDecode [1:0] $end
$var wire 32 T filtered_instruction [31:0] $end
$var wire 1 U exe_writeToReg $end
$var wire 32 V exe_writeData [31:0] $end
$var wire 4 W exe_readRegSec [3:0] $end
$var wire 4 X exe_readRegFirst [3:0] $end
$var wire 4 Y exe_readRegDest [3:0] $end
$var wire 1 Z exeOverride $end
$var wire 16 [ exeData [15:0] $end
$var wire 1 \ dataRegisterImm $end
$var wire 1 ] dataRegister $end
$var wire 32 ^ dataOut [31:0] $end
$var wire 4 _ branchInstruction [3:0] $end
$var wire 1 ` branch $end
$var wire 3 a aluFunction [2:0] $end
$var wire 32 b addressIn [31:0] $end
$var reg 32 c data_memory_v [31:0] $end
$var reg 2 d err_bits [1:0] $end
$var reg 32 e instruction_memory_v [31:0] $end
$scope module EXE $end
$var wire 1 % clk $end
$var wire 16 f exeData [15:0] $end
$var wire 32 g memoryDataIn [31:0] $end
$var wire 1 ' rst $end
$var wire 1 C specialEncoding $end
$var wire 4 h sourceSecReg [3:0] $end
$var wire 4 i sourceFirstReg [3:0] $end
$var wire 1 D setFlags $end
$var wire 4 j secondLevelDecode [3:0] $end
$var wire 32 k readDataSec [31:0] $end
$var wire 32 l readDataFirst [31:0] $end
$var wire 32 m readDataDest [31:0] $end
$var wire 16 n imm [15:0] $end
$var wire 2 o firstLevelDecode [1:0] $end
$var wire 4 p destReg [3:0] $end
$var wire 4 q branchInstruction [3:0] $end
$var wire 3 r aluFunctions [2:0] $end
$var reg 33 s aluRegister [32:0] $end
$var reg 1 Z exeOverride $end
$var reg 4 t flags [3:0] $end
$var reg 4 u flags_next [3:0] $end
$var reg 32 v immExt [31:0] $end
$var reg 32 w memoryAddressOut [31:0] $end
$var reg 32 x memoryDataOut [31:0] $end
$var reg 1 ) memoryRead $end
$var reg 1 ( memoryWrite $end
$var reg 4 y readRegDest [3:0] $end
$var reg 4 z readRegFirst [3:0] $end
$var reg 4 { readRegSec [3:0] $end
$var reg 33 | tempDiff [32:0] $end
$var reg 32 } writeData [31:0] $end
$var reg 1 U writeToReg $end
$upscope $end
$scope module ID $end
$var wire 1 % clk $end
$var wire 1 ' rst $end
$var wire 1 ~ specialBit $end
$var wire 4 !" sourceSecReg [3:0] $end
$var wire 4 "" sourceFirstReg [3:0] $end
$var wire 4 #" secondLevelDecode [3:0] $end
$var wire 7 $" opcode [6:0] $end
$var wire 32 %" instruction [31:0] $end
$var wire 16 &" imm [15:0] $end
$var wire 2 '" firstLevelDecode [1:0] $end
$var wire 4 (" destReg [3:0] $end
$var wire 4 )" branchCondition [3:0] $end
$var wire 3 *" aluOperationCommands [2:0] $end
$var reg 3 +" aluFunction [2:0] $end
$var reg 1 ` branch $end
$var reg 4 ," branchInstruction [3:0] $end
$var reg 1 ] dataRegister $end
$var reg 1 \ dataRegisterImm $end
$var reg 2 -" firstLevelDecode_out [1:0] $end
$var reg 1 - halt $end
$var reg 1 Q loadStore $end
$var reg 1 P mul_trigger $end
$var reg 4 ." out_destRegister [3:0] $end
$var reg 16 /" out_imm [15:0] $end
$var reg 4 0" out_sourceFirstReg [3:0] $end
$var reg 4 1" out_sourceSecReg [3:0] $end
$var reg 1 G regRead $end
$var reg 1 F regWrite $end
$var reg 4 2" secondLevelDecode_out [3:0] $end
$var reg 1 D setFlags $end
$var reg 1 C specialEncoding $end
$upscope $end
$scope module IF $end
$var wire 1 % clk $end
$var wire 16 3" exeData [15:0] $end
$var wire 1 Z exeOverride $end
$var wire 32 4" fetchedInstruction [31:0] $end
$var wire 16 5" imm16_exe [15:0] $end
$var wire 1 ' rst $end
$var wire 1 P ucode_trigger $end
$var wire 16 6" imm16 [15:0] $end
$var wire 32 7" branchOffsetAddress_exe [31:0] $end
$var wire 32 8" branchOffsetAddress [31:0] $end
$var parameter 32 9" sFilter $end
$var parameter 32 :" sIdle $end
$var reg 32 ;" PC [31:0] $end
$var reg 32 <" PC_next [31:0] $end
$var reg 32 =" filteredInstruction [31:0] $end
$var reg 32 >" programCounter [31:0] $end
$var reg 2 ?" state [1:0] $end
$var reg 2 @" stateNext [1:0] $end
$upscope $end
$scope module REGFILE $end
$var wire 1 % clk $end
$var wire 32 A" out_rd [31:0] $end
$var wire 32 B" out_rs1 [31:0] $end
$var wire 32 C" out_rs2 [31:0] $end
$var wire 4 D" rd [3:0] $end
$var wire 4 E" rs1 [3:0] $end
$var wire 4 F" rs2 [3:0] $end
$var wire 1 ' rst $end
$var wire 1 U write $end
$var wire 32 G" writeData [31:0] $end
$var integer 32 H" i [31:0] $end
$upscope $end
$scope module Ucode $end
$var wire 1 % clk $end
$var wire 4 I" dest_reg [3:0] $end
$var wire 16 J" immediate [15:0] $end
$var wire 1 ' rst $end
$var wire 4 K" source_reg [3:0] $end
$var wire 1 P start_mul $end
$var parameter 7 L" ADD_OPCODE $end
$var parameter 7 M" MOV_OPCODE $end
$var parameter 7 N" SUB_OPCODE $end
$var parameter 3 O" sClear $end
$var parameter 3 P" sHalt $end
$var parameter 3 Q" sIdle $end
$var parameter 3 R" sKeep_adding $end
$var parameter 3 S" sMov $end
$var reg 16 T" count_next [15:0] $end
$var reg 16 U" count_reg [15:0] $end
$var reg 32 V" output_instruction [31:0] $end
$var reg 3 W" state_next [2:0] $end
$var reg 3 X" state_reg [2:0] $end
$upscope $end
$scope module mux $end
$var wire 1 P control $end
$var wire 32 Y" filtered_instruction [31:0] $end
$var wire 32 Z" ucode_instruction [31:0] $end
$var reg 32 [" finalized_instruction [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
b10 S"
b11 R"
b0 Q"
b100 P"
b1 O"
b110010 N"
b0 M"
b110001 L"
b0 :"
b1 9"
$end
#0
$dumpvars
bx ["
b11001000000000000000000000000000 Z"
bx Y"
b0 X"
b0 W"
b11001000000000000000000000000000 V"
b0 U"
b0 T"
bx K"
bx J"
bx I"
b10000 H"
b0 G"
b0 F"
b0 E"
b0 D"
b0 C"
b0 B"
b0 A"
b0 @"
b0 ?"
b0 >"
bx ="
b100 <"
b0 ;"
b10 8"
bx 7"
b10 6"
bx 5"
b10 4"
bx 3"
bx 2"
bx 1"
bx 0"
bx /"
bx ."
bx -"
bx ,"
bx +"
bx *"
bx )"
bx ("
bx '"
bx &"
bx %"
bx $"
bx #"
bx ""
bx !"
x~
b0 }
b0 |
b0 {
b0 z
b0 y
b0 x
b0 w
b0 v
b0 u
b0 t
bx s
bx r
bx q
bx p
bx o
bx n
b0 m
b0 l
b0 k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
b0 b
bx a
x`
bx _
b0 ^
x]
x\
bx [
0Z
b0 Y
b0 X
b0 W
b0 V
0U
bx T
bx S
bx R
xQ
xP
bx O
bx N
bx M
bx L
b0 K
b0 J
b0 I
b0 H
xG
xF
bx E
xD
xC
b11001000000000000000000000000000 B
bx A
b10 @
bx ?
bx >
bx =
b10 <
bx ;
bx :
bx 9
bx 8
bx 7
b0 6
b0 5
b0 4
13
b0 2
bx 1
b0 0
bx /
bx .
x-
b10 ,
bx +
b0 *
0)
0(
1'
1&
1%
bx $
bx #
bx "
z!
$end
#5
0%
#10
b10000 H"
1%
#15
0%
#20
b10000 H"
1%
#25
0%
#30
b0 <"
b1 @"
0'
b10000 H"
1%
#35
0%
#40
1U
b10 V
b10 }
b10 G"
b0 E
b0 j
b0 2"
b0 S
b0 o
b0 -"
b0 $"
b10 &"
b0 !"
b0 ""
b0 ("
b0 )"
b0 *"
b0 #"
0~
b0 '"
0-
0P
b10 7"
b10 5"
b10 [
b10 f
b10 3"
b10 N
b10 n
b10 /"
b10 J"
b0 L
b0 h
b0 1"
b0 M
b0 i
b0 0"
b0 K"
b0 O
b0 p
b0 ."
b0 I"
1G
1F
b0 _
b0 q
b0 ,"
b0 a
b0 r
b0 +"
xD
0C
1\
0]
0Q
0`
b10 R
b10 %"
b10 ["
b10 T
b10 ="
b10 Y"
b100 <"
b1 ?"
1%
#45
0%
#50
